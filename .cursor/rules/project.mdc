---
alwaysApply: true
---

# Project Rules: Clean Architecture + Simplified Structure + RESTful Design

## ðŸŽ¯ Goal
Maintain a **clean, consistent, and minimalistic Go project structure** aligned with:
- Clean Architecture principles
- YAGNI (You Arenâ€™t Gonna Need It)
- Readability, maintainability, and performance optimization
- RESTful API design consistency

---

## ðŸ§± Project Architecture Rules

- Follow **Clean Architecture** layering:
  - `/api` â†’ HTTP handlers, request/response DTOs  
  - `/service` â†’ Business logic (application layer)
  - `/repository` â†’ Data access (DB, external APIs)
  - `/internal` â†’ Private packages and shared helpers
  - `/pkg` â†’ Optional public utilities reusable across modules
- Avoid deeply nested directories unless strictly necessary.
- Each layer should depend **only inward** (no circular dependencies).
- Keep interfaces minimal; define them where they are used (not globally).

---

## ðŸ“¦ Folder & File Simplification

- Prefer **fewer files** with clear purposes over excessive fragmentation.
- Merge trivial files (e.g., small model definitions) if they serve the same context.
- Avoid unnecessary abstractions; follow **YAGNI** â€” donâ€™t implement until needed.
- Each folder should represent a clear domain boundary or technical concern.
- Consistent naming convention:
  - `user_service.go`, `order_repository.go`, etc.
- Avoid placeholder files (e.g., empty `README.md`, `init.go`).

---

## ðŸŒ RESTful API Guidelines

- Follow RESTful conventions:
  - Use plural resource names (`/users`, `/orders`)
  - Prefer nouns for endpoints, verbs for actions only if necessary (`/users/login`)
  - Use appropriate HTTP verbs and status codes
- Keep handlers small and delegate business logic to the service layer.
- Use DTOs for request/response structs, separate from DB entities.

---

## ðŸ§¹ Code Quality & Readability

- Write **clear, idiomatic Go code**.
- Maintain consistent formatting (use `gofmt`, `goimports`).
- Prefer explicit over implicit behavior.
- Keep functions short, focused, and self-documenting.
- Use meaningful naming for variables, methods, and packages.
- Avoid magic numbers, inline constants, and commented-out code.

---

## âš™ï¸ Optimization Principles

- Prioritize readability and maintainability over micro-optimizations.
- Optimize only after profiling or identifying real bottlenecks.
- Use caching (e.g., Valkey/Redis) appropriately â€” no premature optimization.
- Favor Goâ€™s built-in concurrency primitives (goroutines, channels) when relevant.

---

## ðŸ§­ Consistency Rules

- Follow a **consistent structure across all modules**.
- Match function naming patterns (`Create`, `Get`, `Update`, `Delete`).
- Enforce consistent error handling patterns and logging styles.
- Return well-defined error types, avoid generic `errors.New()` where context is needed.

---

## ðŸš« Anti-patterns to Avoid

- Over-engineered abstractions (e.g., generic repositories with no benefit)
- Deeply nested folder hierarchies
- God packages (everything in one place)
- Unused dependency injection frameworks
- Interface pollution without clear usage

---

## âœ… Example Minimal Structure
```
/cmd/app/main.go
/api/
â”œâ”€â”€ user_handler.go
â”œâ”€â”€ order_handler.go
/service/
â”œâ”€â”€ user_service.go
â”œâ”€â”€ order_service.go
/repository/
â”œâ”€â”€ user_repository.go
â”œâ”€â”€ order_repository.go
/internal/
â”œâ”€â”€ config/
â””â”€â”€ utils/
```


---

> ðŸ§  **Remember:**  
> Keep it clean, consistent, and only as complex as necessary.  
> Simplicity scales better than over-abstraction.
